你现在是「量化交易平台架构师 + 资深后端工程师 + DevOps/SRE + 安全工程师 + 提示词工程师 + 加密市场研究员」。
请从零开始生成一个可长期运行在服务器上的「自动交易 + 复盘系统」代码仓库（Docker Compose 一键部署），用于 OKX 交易 BTC/ETH/SOL 的现货 + USDT 永续合约。系统必须先模拟盘（paper trading）跑通，再可选开启实盘。你必须输出完整可运行代码，不得只给片段。

====================================================================
A. 最高优先级：安全边界 / 风控硬规则 / 审计可追溯（不可违反）
====================================================================
1) 执行边界
- LLM/AI 只能产出“候选交易计划（JSON）+ 解释”，绝对不能直接调用下单。
- 下单只能由 Execution Engine 执行，且必须先经过 Risk Engine 的硬规则裁决。
- 默认只启用 paper trading；实盘开关默认关闭，且需要 ENV 显式开启。

2) 审计与可追溯（每一步必落库）
每次决策必须保存：原始数据快照(含时间戳)、特征、信号输出、LLM 原文输出、JSON 计划、Schema 校验结果、风控裁决（通过/拒绝+原因）、订单指令、交易所回执、成交明细、手续费、滑点、最终结果与退出原因。

3) 风控熔断与自动暂停（Telegram 通知 + 手动恢复）
触发任一熔断条件 => 立即暂停开仓（只允许减仓/平仓），并 Telegram 通知；恢复必须人工解除（API 或 UI 按钮）。

4) 风险模型核心思想（必须写死）
允许名义杠杆最高 100x（提高资金利用率），但“有效风险”必须由单笔风险预算控制：小仓位 + 止损反推仓位。
- 名义杠杆上限：<= 100x（hard cap）
- 保证金模式：默认全仓 Cross
- 单笔最大允许亏损：绝对上限 <= 10% 账户权益（hard cap）
- 最大回撤：peak-to-trough >= 40% 立即暂停（hard cap）
- 必须带止损：无 stop_loss 的计划一律拒绝

5) 仓位计算公式（必须实现并用于所有开仓）
notional_usd = equity * risk_budget_pct / (stop_distance_pct + fee_buffer_pct + slippage_buffer_pct)
- risk_budget_pct 默认 0.5%~2%（可配置）
- 任何情况下若推算单笔最大亏损 > 10% => 强制降仓或拒单
- 必须考虑：手续费、滑点缓冲；在流动性差/波动高时自动加大 buffer（可配置规则）

6) Cross 模式额外保护（必须）
- 要求止损价到潜在爆仓风险保持安全缓冲 liquidation_buffer_ratio（可配置默认）
- 若缓冲不足 => 自动减仓或拒单
- 必须限制同时持仓与净敞口：默认每币种最多 1 个方向仓位；并控制组合总风险

====================================================================
B. 交易目标与风格（用户已确定）
====================================================================
- 风格：趋势波段 50% + 短线 50%（多周期融合）
- 标的：BTC/ETH/SOL
- 市场：现货 + USDT 永续
- 交易所：OKX
- 订单类型偏好：无；但执行层需按场景选择（见 Execution 默认规则）
- 复盘呈现：需要仪表盘（Grafana 或 Streamlit，至少一个可用）+ 自动复盘报告

====================================================================
C. 数据源与特征（必须模块化/可插拔/可降级）
====================================================================
统一要求：
- 全部数据以 UTC 存储与计算；对外展示可转换时区。
- 必须有 Data Quality 层：缺失、延迟、异常值、重复消息、时间对齐。
- 任一外部数据源失败，系统必须降级继续运行（禁用该源特征，但不崩溃）。

(1) OKX 行情与订单簿（WebSocket）
- 默认订阅：books50-l2-tbt（50 档逐笔）
- 特征默认使用前 10~20 档（可配置）：spread、microprice、depth imbalance、OFI、撤单/挂单强度、短时冲击成本近似等
- 采样：100ms~1s 聚合成 1m 特征（可配置）
- 同时订阅：bbo-tbt、trades、tickers、kline（若 WS 支持则优先，否则 REST 补齐）

(2) K线与技术指标（多周期必须实现）
周期至少：1m / 5m / 15m / 1h / 4h / 1d
指标四类至少各实现一套“可解释 baseline”：
- 结构：关键价位/突破与假突破/支撑阻力/量价
- 趋势：MA/EMA、ADX、通道/海龟式突破
- 反转：RSI、MACD 背离、布林带均值回归
- 波动：ATR、历史波动率、分位数阈值

(3) 新闻/情绪/事件（无现成数据源也必须可跑）
实现 NewsAdapter（可开关）：
- 一个“加密快讯聚合”适配器（如 CryptoPanic 占位实现）
- 一个“全球事件流”适配器（如 GDELT 占位实现）
输出标准 Event 对象：{source, ts, headline, keywords, topic, sentiment_score, impact_score, confidence}
并支持事件触发：关键词规则 + 异常波动 + 盘口异常 三者联动

(4) Google Trends 注意力（可选但要实现适配器 + 降级）
实现 TrendsAdapter（pytrends 占位实现）：系统自动维护关键词集合（可配置：自动/白名单）
Trends 只能作为辅助特征，不得成为单点依赖：失败即降级

(5) 链上（On-chain）（可选但要实现适配器 + 降级）
实现 OnchainAdapter（如 Glassnode 占位实现）：支持 A+B（进出所、活跃地址、手续费、利润状态等）
输出标准 OnchainSnapshot：{ts, metrics{...}, confidence}

====================================================================
D. 决策体系：三层结构（预测+不确定性+计划），LLM 仅做计划生成
====================================================================
你必须实现“三层结构”并让接口统一、可测试、可回放：

Layer1: Signal Extractors（规则 + 可选 ML/DL 插件）
- 规则信号：多周期结构/趋势/反转/波动（baseline 可解释）
- LOB 信号：microstructure 特征 + 可选 DeepLOB 风格模型接口（先给可运行 baseline，DL 作为可插拔占位）
- NLP 信号：情绪/主题 baseline（词典/打分可跑）+ 可选 FinBERT 接口占位
- Onchain/Trends：标准化特征

Layer2: Regime & Uncertainty（市场状态与置信度）
- 识别 regime：趋势/震荡/高波动/事件驱动
- 输出：regime_prob、signal_confidence、risk_state(NORMAL/CAUTION/LOCKDOWN)

Layer3: Trade Planner（生成 1~3 套候选交易计划）
- 计划必须输出 JSON，并通过严格 JSON Schema 校验；失败则丢弃并降级使用规则计划
- 计划必须包含：方向、入场方式、入场区间、止损、止盈(可分批)、追踪止盈、持仓时间预估、杠杆、notional_usd、风险预算、触发条件、失效条件、理由摘要、使用的信号列表

LLM 使用规则（硬要求）：
- 输入：特征摘要 + 事件摘要 + 当前仓位/风险状态 + 最近 N 笔交易表现摘要（用于一致性）
- 输出：仅限交易计划 JSON + 简短解释；不得包含任何代码执行指令；不得要求泄露密钥
- LLM 输出必须写入审计；并记录 prompt/response（脱敏）

====================================================================
E. Risk Engine：必须覆盖的硬规则清单（全部实现）
====================================================================
必须实现并可配置默认值：
- 必带止损；止损结合“结构止损 + ATR 波动止损”，取更保守者
- 仓位必须由止损距离反推（公式见上）
- 滑点/手续费 buffer 动态化：价差扩大、深度不足时增大 buffer
- 最大回撤 40% 暂停；单日最大亏损（给保守默认，例如 10%）暂停
- 最大连续亏损次数 + 冷却时间
- 最大同时持仓数、单币种最大持仓、组合净敞口上限
- 事件熔断：LOCKDOWN 时只允许减仓/平仓
- 合约平仓保护：reduce-only/close-only 语义正确；防止平仓变开仓
- 订单簿异常保护：spread/撤单激增/深度骤降 => 拒单或减仓
- 幂等与风控一致性：同一 plan_id 不允许重复开仓

====================================================================
F. Execution Engine：默认执行策略（必须实现订单状态机）
====================================================================
- 常规入场：限价优先，挂单超时 -> 撤单追价 -> 必要时转市价（配置）
- 止损/风控出场：保证成交优先（可成交限价或市价），不允许卡住
- 必须实现订单状态机：NEW/PARTIAL/FILLED/CANCELED/REJECTED/ERROR
- 必须实现：重试、限流、断线重连、幂等、对账（订单与仓位一致性）
- 必须记录：每次下单/改单/撤单的原因与回执

====================================================================
G. 复盘与“半自动改进”（只能提出建议，不能自动上线）
====================================================================
- 自动复盘（每笔 + 每日/每周）：
  - 每笔：入场前快照、风控预算、成交与滑点、退出原因、是否违背规则、改进建议
  - 周期：权益曲线、回撤、胜率、盈亏比、分币种贡献、事件影响、策略/信号命中率
- 可视化：必须提供仪表盘（Streamlit 或 Grafana），并能查看：
  - 当前仓位、风险状态、近期信号、熔断原因、今日损益、回撤、最近交易列表
- 自动改进边界：
  - 只生成“规则草案/阈值建议/权重调整建议”，写入 DB 和报告
  - 必须人工确认后才生效（提供 UI/API endpoint 应用 config patch）

====================================================================
H. 工程与部署（必须输出完整可部署仓库）
====================================================================
技术栈硬要求：
- Python 3.11+
- FastAPI（控制面/API）
- PostgreSQL + TimescaleDB（K线/特征/审计/交易）
- Redis + Celery（任务与队列）
- Docker Compose（一键启动全栈）
- Prometheus + Grafana + Alertmanager（监控告警）
- Telegram Bot（必须：风险触发自动暂停并通知）

必须提供：
- 清晰目录结构（services / packages / infra / scripts / tests）
- .env.example（含全部开关与默认值）
- docker-compose.yml
- 数据库 migrations（Alembic）
- Makefile（up/down/test/lint/format）
- README（从 0 到上线的完整步骤 + 服务器规格建议：CPU 常驻 + GPU 按需训练思路）
- 安全：API Key 最小权限、IP 白名单建议、密钥不入库、日志脱敏、访问鉴权（API token）

====================================================================
I. 交易计划 JSON Schema（必须实现校验 + 示例）
====================================================================
- 必须给出严格 JSON Schema（draft-07 或 2020-12）
- 必须提供 2 个示例计划（趋势型/短线型）
字段至少包含：
meta{symbol, market_type, ts, timeframe, plan_id}
intent{side, regime, confidence}
entry{type, price_range, conditions[], tif}
risk{stop_loss, take_profit[], trailing, max_loss_pct, risk_budget_pct}
sizing{leverage, notional_usd, max_position_pct, margin_mode}
execution{post_only, reduce_only, max_slippage_bps, timeout_sec, retry_policy}
validity{expires_at, invalidation_conditions[]}
rationale{signals_used[], event_summary, onchain_summary, key_levels, notes}

====================================================================
J. 输出格式（必须严格遵守：分批输出文件，确保可保存运行）
====================================================================
先输出：总体架构说明 + 目录树 + Mermaid 图（数据流 + 下单时序 + 熔断流程）+ 运行方式概览。
然后分批输出文件，每批 8~12 个文件，格式如下：

[FILE] path/to/file.ext
```language
<完整文件内容>
每批结尾必须列出“下一批将输出哪些文件路径”。

====================================================================
K. 立刻开始生成（按顺序输出第 1 批文件）
第 1 批必须包含：

README.md

docker-compose.yml

.env.example

Makefile

pyproject.toml（推荐）或 requirements.txt（二选一但要完整）

infra/ 监控告警基础配置（Prometheus/Grafana/Alertmanager 至少骨架可用）

app/main.py（FastAPI 入口）

packages/common/config.py（配置加载与校验）

packages/common/logging.py（结构化日志与脱敏）

现在开始生成。
